"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const client_acm_1 = require("@aws-sdk/client-acm");
const globals_1 = require("../globals");
const certStatuses = ["PENDING_VALIDATION", "ISSUED", "INACTIVE"];
class ACMWrapper {
    constructor(credentials, endpointType) {
        const isEdge = endpointType === globals_1.default.endpointTypes.edge;
        this.acm = new client_acm_1.ACMClient({
            credentials,
            region: isEdge ? globals_1.default.defaultRegion : globals_1.default.getRegion()
        });
    }
    getCertArn(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            let certificateArn; // The arn of the selected certificate
            let certificateName = domain.certificateName; // The certificate name
            try {
                const response = yield this.acm.send(new client_acm_1.ListCertificatesCommand({ CertificateStatuses: certStatuses }));
                // enhancement idea: weight the choice of cert so longer expires
                // and RenewalEligibility = ELIGIBLE is more preferable
                if (certificateName) {
                    certificateArn = this.getCertArnByCertName(response.CertificateSummaryList, certificateName);
                }
                else {
                    certificateName = domain.givenDomainName;
                    certificateArn = this.getCertArnByDomainName(response.CertificateSummaryList, certificateName);
                }
            }
            catch (err) {
                throw Error(`Could not search certificates in Certificate Manager.\n${err.message}`);
            }
            if (certificateArn == null) {
                throw Error(`Could not find an in-date certificate for '${certificateName}'.`);
            }
            return certificateArn;
        });
    }
    getCertArnByCertName(certificates, certName) {
        const found = certificates.find((c) => c.DomainName === certName);
        if (found) {
            return found.CertificateArn;
        }
        return null;
    }
    getCertArnByDomainName(certificates, domainName) {
        // The more specific name will be the longest
        let nameLength = 0;
        let certificateArn;
        for (const currCert of certificates) {
            const allDomainsForCert = [
                currCert.DomainName,
                ...(currCert.SubjectAlternativeNameSummaries || []),
            ];
            for (const currCertDomain of allDomainsForCert) {
                let certificateListName = currCertDomain;
                // Looks for wild card and take it out when checking
                if (certificateListName[0] === "*") {
                    certificateListName = certificateListName.substring(1);
                }
                // Looks to see if the name in the list is within the given domain
                // Also checks if the name is more specific than previous ones
                if (domainName.includes(certificateListName) && certificateListName.length > nameLength) {
                    nameLength = certificateListName.length;
                    certificateArn = currCert.CertificateArn;
                }
            }
        }
        return certificateArn;
    }
}
module.exports = ACMWrapper;
